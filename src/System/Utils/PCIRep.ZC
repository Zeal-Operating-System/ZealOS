#help_index "PCI;Processor;Devices;Info"

//The file was downloaded from
//http://www.pcidatabase.com/reports.php?type=tab-delimeted

#define PCI_DEV_FILE "::/Misc/PCIDevices.DD"

/****
//1) Download http://www.pcidatabase.com/reports.php?type=tab-delimeted
//2) Rename to ::/Misc/PCIDevices.DD
//3) ToDolDoc("::/Misc/PCIDevices.DD");
//4) Edit and remove file header and tail
//5) Text find-and-replace "=0A=" with "". (Doesn't seem necessary anmore.)
//6) Run PCIDevFileGen(). (Doesn't seem necessary anmore.)

public U0 PCIDevFileGen()
{
	Bool first=TRUE,del=FALSE,del2=FALSE,cont=FALSE;
	CDoc *doc=DocRead(PCI_DEV_FILE,
				DOCF_PLAIN_TEXT|DOCF_DBL_DOLLARS|DOCF_NO_CURSOR);
	CDocEntry *doc_e=doc->head.next,*doc_e2;
	while (doc_e!=doc) {
		doc_e2=doc_e->next;
		if (first) {
			if (doc_e->type_u8==DOCT_TEXT) {
				if (doc_e->tag[0]==';')
					del=TRUE;
			}
			first=FALSE;
		}
		if (doc_e->type_u8==DOCT_TEXT && doc_e->tag[StrLen(doc_e->tag)-1]=='=' &&
					doc_e2->type_u8==DOCT_NEW_LINE) {
			doc_e->tag[StrLen(doc_e->tag)-1]=CH_SPACE;
			cont=TRUE;
		}
		del2=del;
		if (doc_e->type_u8==DOCT_NEW_LINE) {
			first=TRUE;
			del2=FALSE;
			if (cont) {
				del=TRUE;
				cont=FALSE;
			}
		}
		if (del)
			DocEntryDel(doc,doc_e);
		del=del2;
		doc_e=doc_e2;
	}
	DocWrite(doc);
}
****/

//$LK,"::/Misc/PCIDevices.DD",A="PI:::/Misc/PCIDevices.DD"$
U0 PCILookUpSingle(CDoc *doc, I64 m, I64 d, U8 **_vendor, U8 **_dev)
{
	Bool		 first = TRUE;
	U8			 buf[8], *vendor = NULL, *dev = NULL;
	CDocEntry	*doc_e = doc->head.next;

	while (doc_e != doc)
	{
		if (first)
		{
			if (doc_e->type_u8 == DOCT_TEXT && doc_e->tag[0] != ';' && StrLen(doc_e->tag) >= 4)
			{
				buf[0](U16) = '0x';
				buf[2](U32) = doc_e->tag(U32 *)[0];
				buf[6] = '\0';
				if (Str2I64(buf) == m)
				{
					doc_e = doc_e->next->next->next;
					if (doc_e->type_u8 == DOCT_TEXT)
					{
						vendor = SysStrNew(doc_e->tag);
						first = FALSE;
						break;
					}
				}
			}
			first=FALSE;
		}
		if (doc_e->type_u8 == DOCT_NEW_LINE)
			first = TRUE;
		doc_e = doc_e->next;
	}

	if (vendor)
	{
		while (doc_e != doc)
		{
			if (first)
			{
				if (doc_e->type_u8 == DOCT_TAB)
				{
					doc_e = doc_e->next->next->next->next;
					if (doc_e->type_u8 == DOCT_TEXT && StrLen(doc_e->tag) >= 4)
					{
						buf[0](U16) = '0x';
						buf[2](U32) = doc_e->tag(U32 *)[0];
						buf[6] = '\0';
						if (Str2I64(buf) == d)
						{
							doc_e = doc_e->next->next->next;
							if (doc_e->type_u8 == DOCT_TEXT)
							{
								dev = SysStrNew(doc_e->tag);
								break;
							}
						}
					}
				}
				else
					break;
				first = FALSE;
			}
			if (doc_e->type_u8 == DOCT_NEW_LINE)
				first = TRUE;
			doc_e = doc_e->next;
		}
	}

	if (vendor)
		*_vendor = vendor;
	else
		*_vendor = SysStrNew("Unknown");

	if (dev)
		*_dev = dev;
	else
		*_dev = SysStrNew("Unknown");
}

U0 PCILookUpDevs()
{
	CPCIDev	*tmppci;
	I64		 w1, w2, b, d, f, timeout = 32 * 8 * 2;
	CDoc	*doc;

	if (dev.pci_head.next != &dev.pci_head)
		return;
	doc = DocRead(PCI_DEV_FILE, DOCF_PLAIN_TEXT | DOCF_NO_CURSOR);
	for (b = 0; b < sys_pci_buses; b++)
		for (d = 0; d < 32; d++)
			for (f = 0; f < 8; f++)
			{
				w1 = PCIReadU16(b, d, f, PCIR_VENDOR_ID);
				Yield; // keep from hanging graphics on bare-metal
				if (w1 != 0xFFFF)
				{
					tmppci = SysCAlloc(sizeof(CPCIDev));
					tmppci->bus = b;
					tmppci->dev = d;
					tmppci->fun = f;
					tmppci->vendor_id = w1;
					tmppci->device_id = w2 = PCIReadU16(b, d, f, PCIR_DEVICE_ID);
					tmppci->sub_code =		PCIReadU8(b, d, f, PCIR_SUB_CODE);
					tmppci->class_code =	PCIReadU8(b, d, f, PCIR_CLASS_CODE);
					tmppci->prog_if = 		PCIReadU8(b, d, f, PCIR_PROG_IF);
					tmppci->revision_id = PCIReadU8(b, d, f, PCIR_REVISION_ID);
					tmppci->bist =				PCIReadU8(b, d, f, PCIR_BIST);
					tmppci->header_type = PCIReadU8(b, d, f, PCIR_HEADER_TYPE);
					tmppci->latency_timer=PCIReadU8(b, d, f, PCIR_LATENCY_TIMER);
					tmppci->capabilities= PCIReadU8(b, d, f, PCIR_CAPABILITIES);
					tmppci->cache_line_size=PCIReadU8(b, d, f, PCIR_CACHE_LINE_SIZE);
					tmppci->subsys_id = 	PCIReadU16(b, d, f, PCIR_SUBSYS_ID);
					tmppci->subsys_vendor_id=PCIReadU16(b, d, f, PCIR_SUBSYS_VENDOR_ID);
					tmppci->erom =				PCIReadU32(b, d, f, PCIR_EXPANSION_ROM);
					tmppci->base[0] = 		PCIReadU32(b, d, f, PCIR_BASE0);
					tmppci->base[1] = 		PCIReadU32(b, d, f, PCIR_BASE1);
					tmppci->base[2] = 		PCIReadU32(b, d, f, PCIR_BASE2);
					tmppci->base[3] = 		PCIReadU32(b, d, f, PCIR_BASE3);
					tmppci->base[4] = 		PCIReadU32(b, d, f, PCIR_BASE4);
					tmppci->base[5] = 		PCIReadU32(b, d, f, PCIR_BASE5);
					PCILookUpSingle(doc, w1, w2, &tmppci->vendor_str, &tmppci->dev_id_str);
					QueueInsert(tmppci, dev.pci_head.last);
					timeout = 32 * 8 * 2;
				}
				else if (sys_pci_buses == 256 && --timeout <= 0)
					goto lud_done;
			}
lud_done:
	DocDel(doc);
}

public CPCIDev *PCIDevFind(U16 class_code=NULL, U16 sub_code=NULL,
												U16 vendor_id=NULL, U16 device_id=NULL,
												U8 _bus=0xFF, U8 _dev=0xFF, U8 _fun=0xFF)
{//return first device with matching class & subcode, vendor & device id, or a specific device.
	PCILookUpDevs;
	CPCIDev *p = dev.pci_head.next;

	while (p != &dev.pci_head)
	{
		if (p->vendor_id == vendor_id && p->device_id == device_id ||
				p->class_code == class_code && p->sub_code == sub_code ||
				p->bus == _bus && p->dev == _dev && p->fun == _fun)

			return p;
 
		p = p->next;
	}
	return NULL;
}

public U0 PCIRep()
{//Report description of PCI devices.
	CPCIDev *tmppci;

	"PCI Buses:%d\n", sys_pci_buses;
	if (!FileFind(PCI_DEV_FILE))
	{
		"You don't have the PCI device file.\n";
		return;
	}
	PCILookUpDevs;
	tmppci = dev.pci_head.next;
	if (!IsRaw)
		"$$LTCYAN$$B :D :F CC-SC-PI\n$$FG$$";
	else
		"B :D :F CC-SC-PI\n";
	while (tmppci != &dev.pci_head)
	{
		"%02X:%02X:%01X %02X-%02X-%02X ",
					tmppci->bus, tmppci->dev, tmppci->fun,
					tmppci->class_code, tmppci->sub_code, tmppci->prog_if;
		if (!IsRaw)
			"$$GREEN$$";
		"%s ", tmppci->vendor_str;
		if (!IsRaw)
			"$$CYAN$$";
		"%s", tmppci->dev_id_str;
		if (!IsRaw)
			"$$FG$$";
		'\n';
					, 
		tmppci=tmppci->next;
	}
}
