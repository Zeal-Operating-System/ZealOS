#help_index "Graphics/Screen"


U0 GrUpdateTaskODEs(CTask *task)
{
	sys_task_being_screen_updated = task;
	try
		ODEsUpdate(task);
	catch
	{
		LBts(&task->win_inhibit, WIf_SELF_ODE);
		"Exception in WinMgr: Update Task ODEs\n";
		PutExcept;
		Sleep(3000);
		LFBFlush;
	}
	sys_task_being_screen_updated = NULL;
}

public I64 GrRect(CDC *dc=gr.dc, I64 x, I64 y, I64 w, I64 h);


U0 GrUpdateTaskWin(CTask *task)
{ //Draw a win. Only Core0 tasks have a win.
	CDC		*dc;
	CD3I64	 saved_scroll;

	sys_task_being_screen_updated = task;
	try
	{
		if (!Bt(&task->display_flags, DISPLAYf_NO_BORDER)) {
			TextBorder(Fs,	task->win_left, task->win_right, task->win_top, task->win_bottom,
							task->border_attr, task == sys_focus_task);
		}

        U64 x = task->win_left * FONT_WIDTH;
        U64 xx = task->win_right * FONT_WIDTH;

        U64 y = task->win_top * FONT_HEIGHT;
        U64 yy = task->win_bottom * FONT_HEIGHT;

		TextRect(task->win_left, task->win_right, task->win_top, task->win_bottom, task->text_attr << 8);

		if (task == sys_winmgr_task)
		{
			if (gr.fp_wall_paper)
				(*gr.fp_wall_paper)(task);
		}
		else if (!(task->win_inhibit & WIF_SELF_DOC))
			DocUpdateTaskDocs(task);
		if (TaskValidate(task))
		{
			if (task->draw_it)
			{
				dc = DCAlias(gr.dc2, task);
				(*task->draw_it)(task, dc);
				DCDel(dc);
			}
			if (TaskValidate(task))
			{
				WinScrollNull(task, &saved_scroll);
				DrawCtrls(task);
				WinScrollRestore(task, &saved_scroll);
			}
		}
	}
	catch
	{
		if (task != Fs && TaskValidate(task))
		{
			LBtr(&task->display_flags, DISPLAYf_SHOW);
			"Exception in WinMgr: Update Task Win\n";
			PutExcept;
			Sleep(3000);
			LFBFlush;
		}
	}
	sys_task_being_screen_updated = NULL;
}

U0 GrUpdateTasks()
{//Only called by WinMgr
	I64		 i;
	CTask	*task, *task1;

	try
	{
		winmgr.ode_time = 0;
		if (Bt(&sys_semas[SEMA_UPDATE_WIN_Z_BUF], 0))
			WinZBufUpdate;
		task1 = task = sys_winmgr_task;
		do
		{ //Loop through Core0 tasks.
			if (!TaskValidate(task))
				break;
			if (Bt(&task->display_flags, DISPLAYf_SHOW) && Bt(gr.win_uncovered_bitmap, task->win_z_num))
				GrUpdateTaskWin(task);
			if (!TaskValidate(task))
				break;
			task = task->next_task;
		}
		while (task != task1);

		for (i = 0; i < mp_count; i++)
		{ //Loop through all cores.
			task1 = task = cpu_structs[i].executive_task;
			do
			{
				if (!TaskValidate(task))
					break;
				GrUpdateTaskODEs(task);
				if (!TaskValidate(task))
					break;
				task = task->next_task;
			}
			while (task != task1);
		}
	}
	catch
	{
		PutExcept(FALSE);
		Debug("Exception in WinMgr");
	}
	winmgr.last_ode_time = winmgr.ode_time;
	ode_alloced_factor = LowPass1(0.1, ode_alloced_factor, Clamp(Gs->idle_factor - 0.1, 0.2, 0.8), 1 / winmgr.fps);
	sys_task_being_screen_updated = NULL;
}

U0 GrFixZoomScale()
{
	gr.screen_zoom = ClampI64(gr.screen_zoom, 1, GR_SCREEN_ZOOM_MAX);
	if (gr.screen_zoom == 1)
	{
		gr.sx = 0;
		gr.sy = 0;
	}
	else
	{
		gr.sx = ClampI64(gr.sx, 0, GR_WIDTH  - GR_WIDTH  / gr.screen_zoom);
		gr.sy = ClampI64(gr.sy, 0, GR_HEIGHT - GR_HEIGHT / gr.screen_zoom);
	}
}

public U0 GrScaleZoom(F64 scale)
{//Multiply zoom factor larger or smaller.
	F64 s = gr.screen_zoom;

	gr.screen_zoom = gr.screen_zoom * scale;
	GrFixZoomScale;
	s /= gr.screen_zoom;
	mouse.scale.x *= s;
	mouse.scale.y *= s;
	mouse.scale.z *= s;
	mouse.offset.x = mouse.pos.x - (mouse.pos.x - mouse.offset.x) * s;
	mouse.offset.y = mouse.pos.y - (mouse.pos.y - mouse.offset.y) * s;
	mouse.offset.z = mouse.pos.z - (mouse.pos.z - mouse.offset.z) * s;
	gr.sx = mouse.pos.x - gr.zoomed_dc->width  >> 1 / gr.screen_zoom;
	gr.sy = mouse.pos.y - gr.zoomed_dc->height >> 1 / gr.screen_zoom;
	GrFixZoomScale;
}

U0 GrZoomInScreen()
{
	I64 i, j, k, l;
	U8 *src, *src2, *dst;

	GrFixZoomScale;

	src = gr.dc2->body + gr.sx + gr.sy * gr.dc2->width_internal;
	dst = gr.zoomed_dc->body;

	for (i = 0; i < GR_HEIGHT / gr.screen_zoom; i++)
	{
		k = gr.screen_zoom;
		while (k--)
		{
			src2 = src;
			for (l = 0; l < GR_WIDTH / gr.screen_zoom; l++)
			{
				for (j = 0; j < gr.screen_zoom - 1; j++)
					*dst++ = *src2;

				*dst++ = *src2++;
			}
		}
		src += GR_WIDTH;
	}
}

U0 GrUpdateText(CDC *dest=gr.dc32)
{//See $LK,"TextBase Layer",A="HI:TextBase Layer"$.
	U32 *src = gr.text_base, *dst32 = dest->body;
	I64  i, j, cur_ch, w1 = dest->width_internal, w2 = (FONT_HEIGHT - 1) * w1, w4 = 0, 
		 num_rows = TEXT_ROWS, num_cols = TEXT_COLS, row, col;
	U32	*dst_start = dest->body, 
		*dst_end = dst_start + w1 * dest->height - (FONT_HEIGHT - 1) * w1 - FONT_WIDTH;
	Bool blink_flag = Blink;
	U32 bgColor;
	U32 fgColor;

	if (gr.pan_text_x || gr.hide_col)
	{
		gr.pan_text_x = ClampI64(gr.pan_text_x, -7, 7);
		j = AbsI64(gr.pan_text_x) / FONT_WIDTH + 1;
		num_cols -= j;
		if (gr.pan_text_x < 0)
		{
			src += j;
            dst32 += FONT_WIDTH * j;
		}
		w4 = j;
		w2 += j * FONT_WIDTH;
	}

	if (gr.pan_text_y || gr.hide_row)
	{
		gr.pan_text_y = ClampI64(gr.pan_text_y, -7, 7);
		j = AbsI64(gr.pan_text_y) / FONT_HEIGHT + 1;
		num_rows -= j;
		if (gr.pan_text_y < 0)
		{
			src += TEXT_COLS * j;
			dst32 += w1 * FONT_HEIGHT * j;
		}
	}

	for (row = num_rows; row--;)
	{
		for (col = num_cols; col--;)
		{
			cur_ch = *src++;
			if (cur_ch & (ATTRF_UNDERLINE | ATTRF_SEL | ATTRF_INVERT | ATTRF_BLINK))
			{
				if (cur_ch & ATTRF_SEL)
					cur_ch.u8[1] = cur_ch.u8[1] ^ 0xFF;
				if (cur_ch & ATTRF_INVERT)
					cur_ch.u8[1] = cur_ch.u8[1] << 4 + cur_ch.u8[1] >> 4;
				if (cur_ch & ATTRF_BLINK && blink_flag)
					cur_ch.u8[1] = cur_ch.u8[1] << 4 + cur_ch.u8[1] >> 4;
			}
			if (i = cur_ch.u16[1]&0x3FF+gr.pan_text_x+gr.pan_text_y<<5) {
				j = i &0x1F;
				if (j & 0x10)
					j |= ~0x1F;
				i >>= 5;
				if (i & 0x10)
					i |= ~0x1F;
				i = w1 * i + j;
				if (dst_start <= dst32 + i < dst_end) {
					bgColor = gr_palette[cur_ch.u8[1] >> 4];
					fgColor = gr_palette[cur_ch.u8[1] & 0xF];
					GrDrawCharNoClippingU32(cur_ch, fgColor, bgColor, dst32 + i, w1);
				}
			}
			else {
				bgColor = gr_palette[cur_ch.u8[1] >> 4];
				fgColor = gr_palette[cur_ch.u8[1] & 0xF];
				GrDrawCharNoClippingU32(cur_ch, fgColor, bgColor, dst32, w1);
			}
            dst32 += 8;
		}
		src += w4;
        dst32 += w2;
	}
}

U0 DCBlotColor8to8(CDC *dest, CDC *source)
{// copy non transparent pixels
	U8 pixel, reg RSI *src = source->body, reg RDI *dst = dest->body;
	I64 i = 0, size = source->width_internal * source->height;

	for (; i < size; i++, src++, dst++)
	{
		pixel = *src;
		if (pixel != TRANSPARENT)
			*dst = pixel;
	}
}

U0 DCBlotColor8to32(CDC *dest, CDC *source) 
{// don't call directly call DCBlot
    U32 reg RDI *dst = dest->body; 
	U8 reg RSI *src = source->body, pixel;
	U64	size = src + source->height * source->width_internal;

    for (; src < size; src++, dst++) 
	{
		pixel = *src;
		if (pixel != TRANSPARENT)
			*dst = source->palette[pixel & 0xF];
    }
}

/**
This really needs 2 implementations
* One full copy
* one conditional copy on transparent
*/
U0 DCBlotColor32to32(CDC *dest, CDC *source) 
{// Don't call directly call DCBlot
	I64 size = source->width_internal * source->height;
    MemCopy(dest->body, source->body, size * 4);
	
}


U0 DCBlot(CDC *dest, CDC *source) 
{  // some things may not be set like saved images
  if (source->bitsPerPixel != 32) {
    if (dest->bitsPerPixel == 32) 
      DCBlotColor8to32(dest, source);
    else
      DCBlotColor8to8(dest, source);

  } else {
    // there is no 'downgrade' for 32bit
    DCBlotColor32to32(dest, source);
  }
}


U0 GrUpdateScreen32(CDC *dest, CDC *source)
{
	if (gr.screen_zoom == 1)
	{
        DCBlot(dest, source);
	}
	else
	{
		GrZoomInScreen;
        DCBlot(dest, gr.zoomed_dc); 
	}
}


U64	tasks_done = 0;


U0 GrTask2(U64) 
{
	GrUpdateText;  // dc32

	lock {tasks_done--;}
}


U0 GrUpdateScreen()
{//Called by the Window Manager $LK,"HERE",A="FF:::/System/WinMgr.ZC,GrUpdateScreen"$, 30 times a second.

	if (text.is_fb_busy)
		return;

    MemSet(gr.dc2->body, TRANSPARENT, gr.dc2->width_internal * gr.dc2->height);
    MemSet(gr.dc->body, TRANSPARENT, gr.dc->width_internal * gr.dc->height);
	while (tasks_done)  // wait for GrUpdateText
		Yield;
	GrUpdateTasks; // write to dc2

	CDC *dc;

	dc = DCAlias(gr.dc2, Fs);
	dc->flags |= DCF_ON_TOP;
	if (gr.fp_final_screen_update)
		(*gr.fp_final_screen_update)(dc);
	DCDel(dc);

    DCBlot(gr.dc2, gr.dc); 
    GrUpdateScreen32(gr.dc32, gr.dc2); // dc2 to back plane

    DCBlot(gr.screen, gr.dc32); // back plane to screen

	// post screen draw prepare next refresh
	tasks_done = 1;
	Spawn(&GrTask2,,, mp_count-1); 

}
