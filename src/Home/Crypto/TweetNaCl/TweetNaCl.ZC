// Cd(__DIR__);;
// #include "TweetNaCl.HH"
// U0 randombytes(U8 *, U64);
U0 randombytes(U8 *array, U64 length) {
	U64 i;
    for (i = 0; i < length; i++) {
        array[i] = RandU8();
    }
}

class gf {
  I64 data[16];
};


U8 _0[16];
U8 _9[32] = {9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			 0, 0
			};


gf gf0;
gf gf1;
gf _121665;
gf D;
gf D2;
gf X;
gf Y;
gf I;

U0 InitGf() {
    // Initialize gf1
	I64 i;
    gf1.data[0] = 1;
    for (i = 1; i < 16; i++) gf1.data[i] = 0;

    // Initialize _121665
    _121665.data[0] = 0xDB41;
    _121665.data[1] = 1;
    for (i = 2; i < 16; i++) _121665.data[i] = 0;

    // Initialize D
    D.data[0] = 0x78a3; D.data[1] = 0x1359; D.data[2] = 0x4dca; D.data[3] = 0x75eb;
    D.data[4] = 0xd8ab; D.data[5] = 0x4141; D.data[6] = 0x0a4d; D.data[7] = 0x0070;
    D.data[8] = 0xe898; D.data[9] = 0x7779; D.data[10] = 0x4079; D.data[11] = 0x8cc7;
    D.data[12] = 0xfe73; D.data[13] = 0x2b6f; D.data[14] = 0x6cee; D.data[15] = 0x5203;

    // Initialize D2
    D2.data[0] = 0xf159; D2.data[1] = 0x26b2; D2.data[2] = 0x9b94; D2.data[3] = 0xebd6;
    D2.data[4] = 0xb156; D2.data[5] = 0x8283; D2.data[6] = 0x149a; D2.data[7] = 0x00e0;
    D2.data[8] = 0xd130; D2.data[9] = 0xeef3; D2.data[10] = 0x80f2; D2.data[11] = 0x198e;
    D2.data[12] = 0xfce7; D2.data[13] = 0x56df; D2.data[14] = 0xd9dc; D2.data[15] = 0x2406;

    // Initialize X
    X.data[0] = 0xd51a; X.data[1] = 0x8f25; X.data[2] = 0x2d60; X.data[3] = 0xc956;
    X.data[4] = 0xa7b2; X.data[5] = 0x9525; X.data[6] = 0xc760; X.data[7] = 0x692c;
    X.data[8] = 0xdc5c; X.data[9] = 0xfdd6; X.data[10] = 0xe231; X.data[11] = 0xc0a4;
    X.data[12] = 0x53fe; X.data[13] = 0xcd6e; X.data[14] = 0x36d3; X.data[15] = 0x2169;

    // Initialize Y
    Y.data[0] = 0x6658; Y.data[1] = 0x6666; Y.data[2] = 0x6666; Y.data[3] = 0x6666;
    Y.data[4] = 0x6666; Y.data[5] = 0x6666; Y.data[6] = 0x6666; Y.data[7] = 0x6666;
    Y.data[8] = 0x6666; Y.data[9] = 0x6666; Y.data[10] = 0x6666; Y.data[11] = 0x6666;
    Y.data[12] = 0x6666; Y.data[13] = 0x6666; Y.data[14] = 0x6666; Y.data[15] = 0x6666;

    // Initialize I
    I.data[0] = 0xa0b0; I.data[1] = 0x4a0e; I.data[2] = 0x1b27; I.data[3] = 0xc4ee;
    I.data[4] = 0xe478; I.data[5] = 0xad2f; I.data[6] = 0x1806; I.data[7] = 0x2f43;
    I.data[8] = 0xd7a7; I.data[9] = 0x3dfb; I.data[10] = 0x0099; I.data[11] = 0x2b4d;
    I.data[12] = 0xdf0b; I.data[13] = 0x4fc1; I.data[14] = 0x2480; I.data[15] = 0x2b83;
}

InitGf;

U32 L32(U32 x, I64 c) { return (x << c) | ((x & 0xffffffff) >> (32 - c)); }

U32 Ld32(U8 *x)
{
    U32 u = x[3];
    u = (u << 8) | x[2];
    u = (u << 8) | x[1];
    return (u << 8) | x[0];
}

U64 Dl64(U8 *x) {
  U64 i, u = 0;
  for (i = 0;i < 8;++i) u |= x[i] << 8 * i; // (U64) x[i] << 8 * i;
  return u;
}

U0 St32(U8 *x, U32 u) {
  I64 i;
  for (i = 0;i < 4;++i) { x[i] = u; u >>= 8; }
}

U0 ts64(U8 *x, U64 u) {
  I64 i;
  for (i = 7; i >= 0; --i) { x[i] = u; u >>= 8; }
}

I64 vn(U8 *x, U8 *y, I64 n) {
  U32 i, d = 0;
  for (i = 0;i < n;++i) d |= x[i] ^ y[i];
  return (1 & ((d - 1) >> 8)) - 1;
}

I64 crypto_verify_16(U8 *x, U8 *y) {
  return vn(x, y, 16);
}

I64 crypto_verify_32(U8 *x, U8 *y) {
  return vn(x, y, 32);
}

U0 core(U8 *out, U8 *in, U8 *k, U8 *c, I64 h) {
    U32 w[16], x[16], y[16], t[4];
    I64 i, j, m;

	for(i=0;i < 4;++i){
        x[5 * i] = Ld32(c + 4 * i);
        x[1 + i] = Ld32(k + 4 * i);
        x[6 + i] = Ld32(in + 4 * i);
        x[11 + i] = Ld32(k + 16 + 4 * i);
    }

	for(i=0;i < 16;++i) y[i] = x[i];
	for(i=0;i < 20;++i){
		for(j=0;j < 4;++j){
			for(m=0;m < 4;++m) t[m] = x[(5 * j + 4 * m) % 16];
            t[1] ^= L32(t[0] + t[3], 7);
            t[2] ^= L32(t[1] + t[0], 9);
            t[3] ^= L32(t[2] + t[1], 13);
            t[0] ^= L32(t[3] + t[2], 18);
			for(m=0;m < 4;++m) w[4 * j + (j + m) % 4] = t[m];
        }
		for(m=0;m < 16;++m) x[m] = w[m];
    }

    if (h) {
		for(i=0;i < 16;++i) x[i] += y[i];
		for(i=0;i < 4;++i) {
            x[5 * i] -= Ld32(c + 4 * i);
            x[6 + i] -= Ld32(in + 4 * i);
        }
        for(i=0;i < 4;++i) {
            St32(out + 4 * i, x[5 * i]);
            St32(out + 16 + 4 * i, x[6 + i]);
        }
    } else {
		for(i=0;i < 16;++i) St32(out + 4 * i, x[i] + y[i]);
    }
}

I64 crypto_core_salsa20(U8 *out, U8 *in, U8 *k, U8 *c) {
  core(out, in, k, c, 0);
  return 0;
}

I64 crypto_core_hsalsa20(U8 *out, U8 *in, U8 *k, U8 *c) {
  core(out, in, k, c, 1);
  return 0;
}

U8 sigma[16] = "expand 32-byte k";

I64 crypto_stream_salsa20_xor(U8 *c, U8 *m, U64 b, U8 *n, U8 *k) {
  U8 z[16], x[64];
  U32 u, i;
  if (!b) return 0;
  for (i = 0;i < 16;++i) z[i] = 0;
  for (i = 0;i < 8;++i) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x, z, k, sigma);
	for (i = 0;i < 64;++i){
		if (m != NULL) {
			c[i] = m[i] ^ x[i];
		} else {
			c[i] = 0 ^ x[i];
		}
	}
	//  c[i] = (m ? m[i] : 0) ^ x[i];
    u = 1;
    for (i = 8; i < 16; ++i) {
      u += z[i]; // (u32 z[i])
      z[i] = u;
      u >>= 8;
    }
    b -= 64;
    c += 64;
    if (m) m += 64;
  }
  if (b) {
    crypto_core_salsa20(x, z, k, sigma);
	for (i = 0;i < b;++i) {
		// c[i] = (m ? m[i] : 0) ^ x[i];
		if (m != NULL) {
			c[i] = m[i] ^ x[i];
		} else {
			c[i] = 0 ^ x[i];
		}
	}
  }
  return 0;
}

I64 crypto_stream_salsa20(U8 *c, U64 d, U8 *n, U8 *k) {
  return crypto_stream_salsa20_xor(c, 0, d, n, k);
}

I64 crypto_stream(U8 *c, U64 d, U8 *n, U8 *k) {
  U8 s[32];
  crypto_core_hsalsa20(s, n, k, sigma);
  return crypto_stream_salsa20(c, d, n + 16, s);
}

I64 crypto_stream_xor(U8 *c, U8 *m, U64 d, U8 *n, U8 *k) {
  U8 s[32];
  crypto_core_hsalsa20(s, n, k, sigma);
  return crypto_stream_salsa20_xor(c, m, d, n + 16, s);
}

U0 add1305(U32 *h, U32 *c) {
  U32 j, u = 0;
  for (j = 0;j < 17;++j){
    u += h[j] + c[j];
    h[j] = u & 255;
    u >>= 8;
  }
}

U32 minusp[17] = {
  5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252
};

I64 crypto_onetimeauth(U8 *out, U8 *m, U64 n, U8 *k) {
  U32 s, i, j, u, x[17], r[17], h[17], c[17], g[17];

  for (j = 0;j < 17;++j) r[j] = h[j] = 0;
  for (j = 0;j < 16;++j) r[j] = k[j];
  r[3]&=15;
  r[4]&=252;
  r[7]&=15;
  r[8]&=252;
  r[11]&=15;
  r[12]&=252;
  r[15]&=15;

  while (n > 0) {
	for (j = 0;j < 17;++j) c[j] = 0;
    for (j = 0; (j < 16) && (j < n); ++j) c[j] = m[j];
    c[j] = 1;
    m += j; n -= j;
    add1305(h, c);
	for (i = 0;i < 17;++i)  {
      x[i] = 0;
	  for (j = 0;j < 17;++j) {
		if (j <= i) {
			x[i] += h[j] * r[i - j];
		} else {
			x[i] += h[j] * (320 * r[i + 17 - j]);
		}
	  }
    }
	for (i = 0;i < 17;++i) h[i] = x[i];
    u = 0;
	for (j = 0;j < 16;++j) {
      u += h[j];
      h[j] = u & 255;
      u >>= 8;
    }
    u += h[16]; h[16] = u & 3;
    u = 5 * (u >> 2);
	for (j = 0;j < 16;++j) {
      u += h[j];
      h[j] = u & 255;
      u >>= 8;
    }
    u += h[16]; h[16] = u;
  }
  for (j = 0;j < 17;++j) g[j] = h[j]; 
  add1305(h, minusp);
  s = -(h[16] >> 7);
  for (j = 0;j < 17;++j) h[j] ^= s & (g[j] ^ h[j]); 
  for (j = 0;j < 16;++j) c[j] = k[j + 16];
  c[16] = 0;
  add1305(h, c);
  for (j = 0;j < 16;++j) out[j] = h[j]; 
  return 0;
}

I64 crypto_onetimeauth_verify(U8 *h, U8 *m, U64 n, U8 *k) {
  U8 x[16];
  crypto_onetimeauth(x, m, n, k);
  return crypto_verify_16(h, x);
}

I64 crypto_secretbox(U8 *c, U8 *m, U64 d, U8 *n, U8 *k) {
  I64 i;
  if (d < 32) return -1;
  crypto_stream_xor(c, m, d, n, k);
  crypto_onetimeauth(c + 16, c + 32, d - 32, c);
  for (i = 0;i < 16;++i) c[i] = 0;
  return 0;
}

I64 crypto_secretbox_open(U8 *m, U8 *c, U64 d, U8 *n, U8 *k) {
  I64 i;
  U8 x[32];
  if (d < 32) return -1;
  crypto_stream(x, 32, n, k);
  if (crypto_onetimeauth_verify(c + 16, c + 32, d - 32, x) != 0) return -1;
  crypto_stream_xor(m, c, d, n, k);
  for (i = 0;i < 32;++i) m[i] = 0;
  return 0;
}

U0 Set25519(gf r, gf a) {
    I64 i;
    for (i = 0; i < 16; ++i) {
        r.data[i] = a.data[i];
    }
}

U0 Car25519(gf o) {
    I64 i, c;
    for (i = 0; i < 16; ++i) {
        o.data[i] += (1 << 16);
        c = o.data[i] >> 16;
        o.data[(i + 1) * (i < 15)] += c - 1 + 37 * (c - 1) * (i == 15);
        o.data[i] -= c << 16;
    }
}

U0 Sel25519(gf p, gf q, I64 b) {
    I64 t, i, c = ~(b - 1);
    for (i = 0; i < 16; ++i) {
        t = c & (p.data[i] ^ q.data[i]);
        p.data[i] ^= t;
        q.data[i] ^= t;
    }
}

U0 Pack25519(U8 *o, I64 *n) {
    I64 i, j, b;
    I64 m[16], t[16];

    for (i = 0; i < 16; ++i) {
        t[i] = n[i];
    }
    Car25519(t);
    Car25519(t);
    Car25519(t);

    for (j = 0; j < 2; ++j) {
        m[0] = t[0] - 0xffed;
        for (i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        Sel25519(t, m, 1 - b);
    }

    for (i = 0; i < 16; ++i) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}

I64 Neq25519(gf a, gf b) {
    U8 c[32], d[32];
    Pack25519(c, a);
    Pack25519(d, b);
    return crypto_verify_32(c, d);
}

U8 Par25519(gf a) {
    U8 d[32];
    Pack25519(d, a);
    return d[0] & 1;
}

U0 Unpack25519(gf o, U8 *n) {
    I64 i;
    for(i=0;i<16;++i) {
        o.data[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o.data[15] &= 0x7fff;
}

// addition
U0 A(gf o, gf a, gf b)
{
  I64 i;
  for (i = 0;i < 16;++i) o.data[i] = a.data[i] + b.data[i];
}

// substraction
U0 Z(gf o, gf a, gf b) {
  I64 i;
  for (i = 0;i < 16;++i) o.data[i] = a.data[i] - b.data[i];
}
// multiply
U0 M(gf o, gf a, gf b) {
  I64 i, j, t[31];
  for (i = 0;i < 31;++i) t[i] = 0;
  for (i = 0;i < 16;++i) { for (j = 0;j < 16;++j) {t[i + j] += a.data[i] * b.data[j];} }
  for (i = 0;i < 15;++i) t[i] += 38 * t[i + 16];
  for (i = 0;i < 16;++i) o.data[i] = t[i];
  Car25519(o);
  Car25519(o);
}
// square
U0 S(gf o, gf a) {
  M(o, a, a);
}

U0 Inv25519(gf *o, gf i) {
    gf c;
    I64 a;

    for (a = 0; a < 16; ++a) c.data[a] = i.data[a];
    for (a = 253; a >= 0; --a) {
        S(c.data, c.data);
        if (a != 2 && a != 4) M(c.data, c.data, i.data);
    }
    for (a = 0; a < 16; ++a) o->data[a] = c.data[a];
}

U0 Pow2523(gf *o, gf i) {
    gf c;
    I64 a;

    for (a = 0; a < 16; ++a) c.data[a] = i.data[a];
    for (a = 250; a >= 0; --a) {
        S(c.data, c.data);
        if (a != 1) M(c.data, c.data, i.data);
    }
    for (a = 0; a < 16; ++a) o->data[a] = c.data[a];
}

U0 Add(gf *p, gf *q) {
    gf a, b, c, d, t, e, f, g, h;

    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);

    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
}

U0 Cswap(gf *p, gf *q, U8 b) {
    I64 i;
    for (i = 0; i < 4; ++i) {
        Sel25519(p[i].data, q[i].data, b);
    }
}

U0 Pack(U8 *r, gf *p) {
    gf tx, ty, zi;
    Inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    Pack25519(r, ty);
    r[31] ^= Par25519(tx) << 7;
}

U0 Scalarmult(gf *p, gf q, U8 *s) {
    I64 i;
    Set25519(p[0], gf0);
    Set25519(p[1], gf1);
    Set25519(p[2], gf1);
    Set25519(p[3], gf0);
    for (i = 255; i >= 0; --i) {
        U8 b = (s[i / 8] >> (i & 7)) & 1;
        Cswap(p, q, b);
        Add(q, p);
        Add(p, p);
        Cswap(p, q, b);
    }
}

U0 Scalarbase(gf *p, U8 *s) {
    gf q[4];
    Set25519(q[0], X);
    Set25519(q[1], Y);
    Set25519(q[2], gf1);
    M(q[3], X, Y);
    Scalarmult(p, q, s);
}

I64 crypto_sign_keypair(U8 *pk, U8 *sk)
{
  U8 d[64];
  gf p[4];
  I64 i;

  randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  Scalarbase(p,d);
  Pack(pk,p);

  for (i = 0; i < 32; i++) sk[32 + i] = pk[i];
  return 0;
}


I64 crypto_Scalarmult(U8 *q, U8 *n, U8 *p) {
    U8 z[32];
    I64 x[80], r, i;
    gf a, b, c, d, e, f;

    for (i = 0; i < 31; ++i) {
        z[i] = n[i];
    }
    z[31] = (n[31] & 127) | 64;
    z[0] &= 248;

    Unpack25519(x, p);

    for (i = 0; i < 16; ++i) {
        d.data[i] = a.data[i] = c.data[i] = 0;
    }
    a.data[0] = d.data[0] = 1;

    for (i = 254; i >= 0; --i) {
        r = (z[i >> 3] >> (i & 7)) & 1;
		Sel25519(a.data,b.data,r);
		Sel25519(c.data,d.data,r);
		A(e,a,c);
		Z(a,a,c);
		A(c,b,d);
		Z(b,b,d);
		S(d,e);
		S(f,a);
		M(a,c,a);
		M(c,b,e);
		A(e,a,c);
		Z(a,a,c);
		S(b,a);
		Z(c,d,f);
		M(a,c,_121665);
		A(a,a,d);
		M(c,c,a);
		M(a,d,f);
		M(d,b,x);
		S(b,e);
		Sel25519(a.data,b.data,r);
		Sel25519(c.data,d.data,r);
    }

    Inv25519(x+32, c+32);
    M(x+16, a+16, x+32);
    Pack25519(q, x+16);

    return 0;
}

I64 crypto_Scalarmult_base(U8 *q, U8 *n) { 
  return crypto_Scalarmult(q, n, _9);
}

I64 crypto_box_keypair(U8 *y, U8 *x) {
  randombytes(x, 32);
  return crypto_Scalarmult_base(y, x);
}

I64 crypto_box_beforenm(U8 *k, U8 *y, U8 *x) {
  U8 s[32];
  crypto_Scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

I64 crypto_box_afternm(U8 *c, U8 *m, U64 d, U8 *n, U8 *k) {
  return crypto_secretbox(c, m, d, n, k);
}

I64 crypto_box_open_afternm(U8 *m, U8 *c, U64 d, U8 *n, U8 *k) {
  return crypto_secretbox_open(m, c, d, n, k);
}

I64 crypto_box(U8 *c, U8 *m, U64 d, U8 *n, U8 *y, U8 *x) {
  U8 k[32];
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

I64 crypto_box_open(U8 *m, U8 *c, U64 d, U8 *n, U8 *y, U8 *x) {
  U8 k[32];
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

U64 R(U64 x, I64 c) { return (x >> c) | (x << (64 - c)); }
U64 Ch(U64 x, U64 y, U64 z) { return (x & y) ^ (~x & z); }
U64 Maj(U64 x, U64 y, U64 z) { return (x & y) ^ (x & z) ^ (y & z); }
U64 Sigma0(U64 x) { return R(x, 28) ^ R(x, 34) ^ R(x, 39); }
U64 Sigma1(U64 x) { return R(x, 14) ^ R(x, 18) ^ R(x, 41); }
U64 sigma0(U64 x) { return R(x, 1) ^ R(x, 8) ^ (x >> 7); }
U64 sigma1(U64 x) { return R(x, 19) ^ R(x, 61) ^ (x >> 6); }

U64 K[80] = 
{
  0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
  0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
  0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
  0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
  0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
  0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
  0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
  0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
  0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
  0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
  0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
  0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
  0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
  0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
  0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
  0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
  0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
  0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
  0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
  0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
};

I64 crypto_hashblocks(U8 *x, U8 *m, U64 n) {
  U64 z[8], b[8], a[8], w[16], t;
  I64 i, j;

  for (i = 0;i < 8;++i) z[i] = a[i] = Dl64(x + 8 * i); 

  while (n >= 128) {
	for (i = 0;i < 16;++i) w[i] = Dl64(m + 8 * i);

	for (i = 0;i < 80;++i) {
	  for (j = 0;j < 8;++j) b[j] = a[j];
      t = a[7] + Sigma1(a[4]) + Ch(a[4],a[5],a[6]) + K[i] + w[i%16];
      b[7] = t + Sigma0(a[0]) + Maj(a[0],a[1],a[2]);
      b[3] += t;
	  for (j = 0;j < 8;++j) a[(j+1)%8] = b[j];
      if (i%16 == 15)
		for (j = 0;j < 16;++j) w[j] += w[(j+9)%16] + sigma0(w[(j+1)%16]) + sigma1(w[(j+14)%16]);
    }

	for (i = 0;i < 8;++i) { a[i] += z[i]; z[i] = a[i]; }

    m += 128;
    n -= 128;
  }

  for (i = 0;i < 8;++i) ts64(x + 8 * i, z[i]); 

  return n;
}
U8 iv[64] = {
  0x6a,0x09,0xe6,0x67,0xf3,0xbc,0xc9,0x08,
  0xbb,0x67,0xae,0x85,0x84,0xca,0xa7,0x3b,
  0x3c,0x6e,0xf3,0x72,0xfe,0x94,0xf8,0x2b,
  0xa5,0x4f,0xf5,0x3a,0x5f,0x1d,0x36,0xf1,
  0x51,0x0e,0x52,0x7f,0xad,0xe6,0x82,0xd1,
  0x9b,0x05,0x68,0x8c,0x2b,0x3e,0x6c,0x1f,
  0x1f,0x83,0xd9,0xab,0xfb,0x41,0xbd,0x6b,
  0x5b,0xe0,0xcd,0x19,0x13,0x7e,0x21,0x79
};

I64 crypto_hash(U8 *out, U8 *m, U64 n) {
  U8 h[64], x[256];
  U64 i, b = n;
  
  for (i = 0;i < 64;++i) h[i] = iv[i]; 

  crypto_hashblocks(h, m, n);
  m += n;
  n &= 127;
  m -= n;

  for (i = 0;i < 256;++i) x[i] = 0;
  for (i = 0;i < n;++i) x[i] = m[i];
  x[n] = 128;

  n = 256 - 128 * (n < 112);
  x[n - 9] = b >> 61;
  ts64(x + n - 8, b << 3);
  crypto_hashblocks(h, x, n);
  for (i = 0;i < 64;++i)  out[i] = h[i];

  return 0;
}

U0 Add(gf *p, gf *q) {
    gf a, b, c, d, t, e, f, g, h;
    
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);

    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
}

U64 L[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10};

U0 modL(U8 *r, I64 *x) {
    I64 carry, i, j, index;
    for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32; j < i - 12; ++j) {
            index = j - (i - 32);
            if (index >= 0 && index < 32) {
                x[j] += carry - 16 * x[i] * L[index];
            }
            carry = (x[j] + 128) >> 8;
            x[j] -= carry << 8;
        }
        x[j] += carry;
        x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
    }
    for (j = 0; j < 32; j++) x[j] -= carry * L[j];
    for (i = 0; i < 32; i++) {
        x[i+1] += x[i] >> 8;
        r[i] = x[i] & 255;
    }
}

U0 reduce(U8 *r)
{
  I64 x[64], i;
  for (i = 0; i < 64; i++) x[i] = r[i]; //(U64) r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

I64 crypto_sign(U8 *sm, U64 *smlen, U8 *m, U64 n, U8 *sk)
{
  U8 d[64], h[64], r[64];
  I64 i, j, x[64];
  gf p[4];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  *smlen = n+64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm+32, n+32);
  reduce(r);
  Scalarbase(p,r);
  Pack(sm,p);

  for (i = 0; i < 32; i++) sm[i+32] = sk[i+32];
  crypto_hash(h,sm,n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i]; // (U64) r[i];
  for (i = 0; i < 32; i++) for (j = 0; j < 32; j++) x[i+j] += h[i] * d[j]; //x[i+j] += h[i] * (U64) d[j];
  modL(sm + 32,x);

  return 0;
}
I64 UnpackNeg(gf *r, U8 *p) {
    gf t, chk, num, den, den2, den4, den6;
    Set25519(r[2], gf1);
    Unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);

    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);

    Pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);

    S(chk, r[0]);
    M(chk, chk, den);
    if (Neq25519(chk, num)) M(r[0], r[0], I);

    S(chk, r[0]);
    M(chk, chk, den);
    if (Neq25519(chk, num)) return -1;

    if (Par25519(r[0]) == (p[31] >> 7)) Z(r[0], gf0, r[0]);

    M(r[3], r[0], r[1]);
    return 0;
}

I64 crypto_sign_open(U8 *m, U64 *mlen, U8 *sm, U64 n, U8 *pk)
{
  I64 i;
  U8 t[32], h[64];
  gf p[4], q[4];

  *mlen = -1;
  if (n < 64) return -1;

  if (UnpackNeg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  Scalarmult(p, q, h);

  Scalarbase(q, sm + 32);
  Add(p, q);
  Pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, t)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  *mlen = n;
  return 0;
}

// U8 public_key[32];
// U8 private_key[64];

// crypto_box_keypair(public_key, private_key);
